* 예외 케이스 생각하기
> 양끝값{0,10000}, 중복값{2,2,2}, 0값(min값), max값, 음수, long long 범위... 등등
> 그래프관련 문제 풀경우, 중복간선 꼭 생각하기. ex) 1 2 1, 1 2 10 (1->2까지 1, 1->2까지 10)

* 가장 자주 실수하는 요인
> 문제 똑바로 안읽음 !!!!!!!!!!!!!
> BFS는 큐에서 뺀 다음이 아닌 큐에 넣을때 방문체크를 해야 중복방문 일어나지 않음
> DFS로 최단거리는 구하지 말기(대부분 TLE)
> 어떠한 값이 int범위 초과하는경우( 인덱스 or 값 or ...) : 그냥 계산하지말고 자료형 모두 long long으로 쓰기
> y,x구분 i,j구분
> 쿼리가 많은경우 배열or컨테이너 초기화
>> 1. 쿼리가 여러개 일때 `resize()`가 필요하다면, `clear()`를 항상 먼저해주기
>> 2. 쿼리가 여러개 일때 선언한 **모든** `배열`, `컨테이너`에 관하여 memset 또는 clear(), resize() 항상!!! 생각하기
> 반환이 있는 함수생성시 특정조건에만 return걸어주지 말고,
>> 오류케이스 방지용으로 기본 return도 적어주기(ex 함수 맨끝줄에 return -1)

# 0. 그냥.... 오류
> while(true)은 왠만해선 쓰지말자.
> 인덱싱 오류... -> for(i=0; i< N; i++) 으로 계산하기 위해 인덱스를 하나씩 빼줬을때 ex) m[a-1][b-1] = c; 이때,
>> 입력값에 a,b,c말고 X가 더 있을때 m[i][X] 와같이 인덱싱하다가 계속 오류남... (X-1로 인덱싱해야함..)
>> 따라서, 입력이 0이아닌 1부터 들어올경우 i=1; 부터 처리하자


*****************************************************************************************************************
# 1. BFS 문제 오류
> 0. 간단한 실수 : pop() 자꾸 까먹음...., push하고 방문처리 바로 안해줌....
> 1. bfs인데 방문처리를 안하여(공간복잡도가 지수스케일로 증가) 메모리초과남
> 2. 방문처리를 했지만,,,, 조건에 방문여부 탐색을 안함.....
> 3. BOJ_13913 에서 X+1, X*2 의경우 K를 넘어서 bfs탐색이 가능한데, K까지만 탐색함
> 4. MAX를 100001으로 지정하고, 범위 조건에서 x+1<=MAX로 지정하여 Index out of range맞음
> 5. 정답 출력을 따로 저장하여 bfs가 끝나고 출력하도록 했는데, N==K 인 case에서 오류가남
>>   (while문 조건에서 cur==K일경우 break시키고 bfs종료후 스택에 저장된 수들 출력했기 때문)
> 6. 단순BFS로 안풀리는경우 ex) <벽 부수고 이동하기>-BOJ_2206 , <숨바꼭질 5>-BOJ_17071
>>   단순BFS를 사용할 경우 포함하지 못하는 노드(경로)가 생김
> 7. 방문범위가 1~10억까지 많은경우 bool vi[1e9]{}를 선언하면 950MB차지 -> Map으로 방문확인
>>   메모리가 250M넘어가면 탐색 속도도 느려짐, 메모리제한 확인해야함

* 해결
> 0. bfs의 기본중 기본 pop(), push후 꼭 방문처리(pop후에 push하거나 안하면 중복탐색하는 노드가 생김)
> 1. bfs사용시 방문처리 무조건 해야함.
> 2. 하..... 방문체크할때는 방문 조건도 꼭 같이....
> 3. 탐색시 탐색범위 모든 범위로 탐색하기 인지하기
> 4. 상수선언시 10의 제곱꼴로 선언(10001 -> X), 범위비교 조심( '='을 넣을지 말지)
> 5. bfs,dfs 탐색후 결과출력은 bfs or dfs가 끝나고 출력하지말고 조건을 탐색도중 조건 만족시 바로 출력하기
>>    도중 출력이 불가한경우, 예외case 항상 생각(양끝값{0,10000}, 중복값{2, 2}, 0값(min값), max값, 음수, long long)
> 6. 위처럼 문제 조건에 맞는 경로를 모두 탐색하지 못하는 경우(다른 가중치가 필요하다거나.. 어떠한 조건에 의해 경로가 겹친다거나..)
>>   방문처리를 할때 다차원 방문을 통해 다른 경로를 탐색하는 방법을 사용. ex( bool vi[2][MAX];)
> 7. Map을 이용한 방문처리로 메모리를 줄일 수 있다.


*****************************************************************************************************************
# 2. DP문제 ( <팔굽혀펴기> - BOJ_10564) 풀이중 오류

> 1. 각 테스트 케이스마다 2차원벡터로 push_back()이 필요해서 v.resize(N+1)를 해야하는데
>>     v.assign(N+1)으로 계속 생각함
>>      v.resize(N+1)로 고치고 나서 다음 테케가 들어오기전에 v.clear후에 resize시켜줘야하는데 안함
> 2. 메모리초과: 위의 v에 data를 추가하는경우 중복수가 들어오는 경우를 생각하지 못하여 메모리초과가 나옴
>>     -> 중복수가 들어올 경우 i가 증가할수록 추가해야하는 수가 중복으로 인해 기하급수적으로 늘어날 수 있음
> 3. 2번까지 문제를 해결했지만, TLE를 맞음...

* 해결
> 1. 쿼리가 여러개 일때 `resize()`가 필요하다면, `clear()`를 항상 먼저해주기
> 2. 스택에 데이터가 들어오는경우 `중복 데이터` 항상 체크 !
> 3. BOJ_10564풀이 익혀두기

*****************************************************************************************************************
# 3. 다익스트라 풀이중 오류
> 1. <숨바꼭질3> - BOJ_13549
>> 가중치(문제에서는 1,0)가 다르므로 다익스트라를 사용하여 큐에 넣는 순서가 상관없어야 하지만
>> N이 1인경우 +1먼저넣으면 2에 dis가 +1되어 가중치0보다 먼저탐색되어 오류.


*****************************************************************************************************************
# 4. sort()중 오류
> vector<int> v(10); 으로 선언해 놓고
> 예를들어 N=5일때 v[0]~v[4] 까지 입력받은후 sort(v.begin(),v.end()); 시전함...
> v[0]~v[9] 까지 sort하므로 index 0~4까지는 0이 들어가는 오류발생

* 해결
> v.resize(N) 꼭 쓰자ㄴ


*****************************************************************************************************************
# 5. list 컨테이너 사용중 오류
> 1) list원소가 삭제되어 size가 0이 되는 경우를 생각못함.
> 2) for문으로 list 탐색시, list원소를 삭제할 경우 참조할 메모리를 잃어버려 ++it실행시 오류가남 (temp 쓰기...)
> 3) for문으로 list 탐색시, 2중for문에서 초기화할때 auto it2 = it1++; 이라고 하면 lt1까지 같이 ++됨
>> 따라서 it2에서 it1를 참조해야 하는 경우 아래와 같이 코딩

~~~cpp
list<int> lt;

for(auto it1 = lt.begin(); it1!=lt.end(); ++it1){
    auto it2 = it1;  // 3)에 해당
    ++it2;
    for( ; it2!=lt.end(); ++it2){
        if(...) {
            // 2)에 해당
            auto tmp = it2;
            --it2;
            lt.erase(tmp);
        }
    }
}
~~~


*****************************************************************************************************************
# 6. 파라메트릭 서치 풀이 중 오류
> 1) 파라메트릭 서치할때 isPossible이 true가 될 수 있는 mid가 여러가지가 있는경우 mid(탐색값)의 최대 or 최소를 구해야 함
> 2) N,M에서 N: 데이터 개수, M: search기준 일때, 코드에서 M과 N을 바꿔서 런타임오류가 남
> 3) 파라메트릭 서치로로 반환되는 값이 MOD일때 MOD가 1이 되는경우 모든수%MOD = 0 이기때문에 오류가 생김.
>> 다른 알고리즘 풀이에서도 생길 수 있는 오류임!!!



*****************************************************************************************************************
# 7. 플로이드 와샬 풀이중 오류
* for(int i=1; i<=N; i++) m[i][i] = 0; 코드 포함시키기!!
> 플로이드와샬을 수행하면 
> 다른곳을거쳐 다시 자기자신의 노드로 돌아오는 최단거리도 계산이 되기때문에
> 내 코드에서 결과계산에 자기자신을 포함시켜야 하는지 아닌지 확인해야함!



*****************************************************************************************************************
# 7. typedef 사용중 오류 (전처리)
~~~cpp
#include<iostream>
#include<string>
#include<vector>
#include<algorithm>
#define xx first
#define yy second
typedef pair<string, int> psi;
using namespace std;

vector<psi> v; // 여기서 psi를 인식못함
~~~
> typedef pair<string, int> psi; <- 이 코드를 using namespace std; 위에 선언했기 때문.
>> typedef는 using namespace std;를 선언후 처리



*****************************************************************************************************************
# 팔굽혀펴기 다시 풀어야 함


